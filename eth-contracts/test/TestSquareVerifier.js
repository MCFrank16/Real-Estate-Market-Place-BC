// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var verifierContract = artifacts.require('Verifier');
const proofFromFile = require("../../zokrates/code/square/proof.json");

const getProofAsUint = (proofCheck) => {
  return {
    "proof": {
      "a": [web3.utils.toBN(proofCheck.proof.a[0]).toString(), web3.utils.toBN(proofCheck.proof.a[1]).toString()],
      "b": [[web3.utils.toBN(proofCheck.proof.b[0][0]).toString(), web3.utils.toBN(proofCheck.proof.b[0][1]).toString()],
      [web3.utils.toBN(proofCheck.proof.b[1][0]).toString(), web3.utils.toBN(proofCheck.proof.b[1][1]).toString()]
      ],
      "c": [web3.utils.toBN(proofCheck.proof.c[0]).toString(), web3.utils.toBN(proofCheck.proof.c[1]).toString()],
    },
    "inputs": proofCheck.inputs
  };
};


contract("TestSquareVerifier", (accounts) => {

  const account_one = accounts[0];

  describe("Check verifier functions", function () {
    beforeEach(async function () {
      this.verifier = await verifierContract.new.call({ from: account_one });

    });

    // Test verification with correct proof
    // - use the contents from proof.json generated from zokrates steps
    it("Correct Proof", async function () {
      const proofCheck = getProofAsUint(proofFromFile);

      let res = await this.verifier.verifyTx.call(
        proofCheck.proof.a,
        proofCheck.proof.b,
        proofCheck.proof.c,
        proofCheck.inputs,
        {
          from: account_one
        }
      );

      assert.equal(res, true, "Wrong proof!");
    });


    // Test verification with incorrect proof

    it("Wrong Proof", async function () {
      let proofWrong = {
        proof: {
          "a": [
            "0x07fc0cca52c70e2ac853f791d4f6d5e2f76ca4a9b6f39193bc9d925aa3cac2f1",
            "0x2c44b955c701b0a9ae6aef93729087443a4410e890a7bd213e9a2827ed6ba15e"
          ],
          "b": [
            [
              "0x280152b43f03050302cfeafbf970bbe6b2fe833252e4249d5c7a4e31f31891c5",
              "0x2a1c20ffff73d20aea2d450f6d573d3121f9c3984613dc93c0c8deeed0f5c99f"
            ],
            [
              "0x08013e792df7103b3f92a92b37c9f6ef9e7214703f724b18330dba3eded10a1e",
              "0x13190c66542b8a4d6de9a393de34c4e7e85c54ccf5e5d06421849b6cdea60450"
            ]
          ],
          "c": [
            "0x2541d82d855d98e5d148e5228c3a2d55706c723103691e06b02431ab6356b1eb",
            "0x287d5eb9fd6108f9ac4ed5483ca0783141283fb7e1bc89ae024fad17ebf93be2"
          ]
        },
        "inputs": [
          "0x0000000000000000000000000000000000000000000000000000000000000002",
          "0x0000000000000000000000000000000000000000000000000000000000000005"
        ]
      };

      const proofCheckWrong = getProofAsUint(proofWrong);

      let res = await this.verifier.verifyTx.call(
        proofCheckWrong.proof.a,
        proofCheckWrong.proof.b,
        proofCheckWrong.proof.c,
        proofCheckWrong.inputs,
        { from: account_one }
      )

      assert.equal(res, false, "it happens to be a correct proof");
    });

  });

})
